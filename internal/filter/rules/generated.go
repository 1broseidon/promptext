package rules

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/1broseidon/promptext/internal/filter/types"
	"github.com/1broseidon/promptext/internal/log"
)

type GeneratedFileRule struct {
	types.BaseRule
	sizeThresholdMB int64
}

func NewGeneratedFileRule(sizeThresholdMB int64) types.Rule {
	if sizeThresholdMB <= 0 {
		sizeThresholdMB = 1 // Default 1MB threshold
	}

	return &GeneratedFileRule{
		BaseRule:        types.NewBaseRule("generated", types.Exclude),
		sizeThresholdMB: sizeThresholdMB * 1024 * 1024,
	}
}

// Common generated file patterns
var generatedPatterns = []string{
	// Build outputs
	"*.min.js",
	"*.min.css",
	"*.bundle.js",
	"*.bundle.css",
	"*.map", // Source maps

	// Compiled assets
	"*.wasm",

	// IDE and tool generated
	".vscode/settings.json",
	".idea/workspace.xml",

	// Package manager generated
	".yarn/cache/",
	".yarn/install-state.gz",
	"node_modules/.cache/",
}

func (r *GeneratedFileRule) Match(path string) bool {
	basename := filepath.Base(path)

	// Check against known generated patterns
	for _, pattern := range generatedPatterns {
		matched, _ := filepath.Match(pattern, basename)
		if matched {
			log.Debug("Excluding generated file pattern: %s", path)
			return true
		}
	}

	// Check file characteristics
	fileInfo, err := os.Stat(path)
	if err != nil || fileInfo.IsDir() {
		return false
	}

	// Large files (>1MB) that might be generated
	if fileInfo.Size() > r.sizeThresholdMB {
		// Check for generation markers
		if hasGeneratedMarkers(path) {
			log.Debug("Excluding large generated file: %s (%d MB)",
				path, fileInfo.Size()/(1024*1024))
			return true
		}

		// Check for low entropy (repetitive structure)
		if hasLowEntropy(path) {
			log.Debug("Excluding large low-entropy file: %s", path)
			return true
		}
	}

	return false
}

var generatedMarkers = []string{
	"autogenerated",
	"auto-generated",
	"automatically generated",
	"do not edit",
	"DO NOT EDIT",
	"DO NOT MODIFY",
	"generated by",
	"This file is automatically",
	"@generated",
	"Code generated by",
	"WARNING: This file is auto-generated",
}

func hasGeneratedMarkers(path string) bool {
	content, err := readFileHeader(path, 2048)
	if err != nil {
		return false
	}

	contentLower := strings.ToLower(content)
	for _, marker := range generatedMarkers {
		if strings.Contains(contentLower, strings.ToLower(marker)) {
			return true
		}
	}

	return false
}

func hasLowEntropy(path string) bool {
	content, err := readFileHeader(path, 8192)
	if err != nil {
		return false
	}

	lines := strings.Split(content, "\n")
	if len(lines) < 20 {
		return false
	}

	// Analyze line patterns
	patterns := make(map[string]int)
	sampleSize := min(50, len(lines))

	for _, line := range lines[:sampleSize] {
		pattern := normalizeLineToPattern(line)
		patterns[pattern]++
	}

	// If >60% of lines follow same pattern, likely generated
	for _, count := range patterns {
		if float64(count)/float64(sampleSize) > 0.6 {
			return true
		}
	}

	return false
}

var (
	versionRegex = regexp.MustCompile(`\d+\.\d+\.[\d\w-]+`)
	hashRegex    = regexp.MustCompile(`[a-f0-9]{32,}`)
	quotedRegex  = regexp.MustCompile(`"[^"]{10,}"`)
)

func normalizeLineToPattern(line string) string {
	// Normalize to detect repetitive structure
	line = versionRegex.ReplaceAllString(line, "VERSION")
	line = hashRegex.ReplaceAllString(line, "HASH")
	line = quotedRegex.ReplaceAllString(line, "STRING")

	// Remove leading/trailing whitespace
	return strings.TrimSpace(line)
}
