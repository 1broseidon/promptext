package rules

import (
	"os"
	"path/filepath"
	"strings"

	"github.com/1broseidon/promptext/internal/filter/types"
	"github.com/1broseidon/promptext/internal/log"
)

type LockFileRule struct {
	types.BaseRule
}

func NewLockFileRule() types.Rule {
	return &LockFileRule{
		BaseRule: types.NewBaseRule("lockfile", types.Exclude),
	}
}

// Known lock file patterns with their signatures
var lockFilePatterns = map[string]lockFilePattern{
	// Node.js ecosystem
	"package-lock.json": {
		signatures: []string{`"lockfileVersion"`, `"packages":`},
		minSize:    1000, // Lock files are typically >1KB
	},
	"yarn.lock": {
		signatures: []string{`# yarn lockfile v`, `__metadata:`},
		minSize:    500,
	},
	"pnpm-lock.yaml": {
		signatures: []string{`lockfileVersion:`, `dependencies:`},
		minSize:    500,
	},
	"bun.lockb": {
		binary:  true,
		minSize: 100,
	},
	".pnp.cjs": {
		signatures: []string{`PnP files are never meant to be edited`, `Yarn Plug'n'Play`},
		minSize:    1000,
	},

	// PHP
	"composer.lock": {
		signatures: []string{`"_readme"`, `"content-hash"`, `"packages":`},
		minSize:    1000,
	},

	// Python
	"poetry.lock": {
		signatures: []string{`# This file is automatically @generated by Poetry`, `[[package]]`},
		minSize:    500,
	},
	"Pipfile.lock": {
		signatures: []string{`"_meta"`, `"pipfile-spec":`},
		minSize:    500,
	},
	"pdm.lock": {
		signatures: []string{`[metadata]`, `lock_version =`},
		minSize:    500,
	},

	// Ruby
	"Gemfile.lock": {
		signatures: []string{`GEM`, `  remote:`, `  specs:`},
		minSize:    200,
	},

	// Rust
	"Cargo.lock": {
		signatures: []string{`# This file is automatically @generated by Cargo`, `version = `, `[[package]]`},
		minSize:    500,
	},

	// Go
	"go.sum": {
		// Each line: module version/hash format
		signatures: []string{` h1:`, `/go.mod `},
		minSize:    100,
	},

	// .NET
	"packages.lock.json": {
		signatures: []string{`"version"`, `"dependencies"`, `"contentHash"`},
		minSize:    500,
	},
	"project.assets.json": {
		signatures: []string{`"version"`, `"targets"`, `"project":`},
		minSize:    1000,
	},

	// Java/Gradle
	"gradle.lockfile": {
		signatures: []string{`# This is a Gradle generated file`},
		minSize:    200,
	},
}

type lockFilePattern struct {
	signatures []string
	binary     bool
	minSize    int64
}

func (r *LockFileRule) Match(path string) bool {
	basename := filepath.Base(path)

	// Check against known patterns
	if pattern, exists := lockFilePatterns[basename]; exists {
		// Verify file size first (cheap check)
		fileInfo, err := os.Stat(path)
		if err != nil || fileInfo.Size() < pattern.minSize {
			return false
		}

		// For binary files, extension match is enough
		if pattern.binary {
			log.Debug("Excluding binary lock file: %s", path)
			return true
		}

		// For text files, verify signatures
		if hasLockFileSignatures(path, pattern.signatures) {
			log.Debug("Excluding lock file: %s (matched %d signatures)", path, len(pattern.signatures))
			return true
		}
	}

	// Catch .lock extension files that look like lock files
	if strings.HasSuffix(basename, ".lock") {
		if looksLikeLockFile(path) {
			log.Debug("Excluding .lock file based on heuristics: %s", path)
			return true
		}
	}

	return false
}

func hasLockFileSignatures(path string, signatures []string) bool {
	content, err := readFileHeader(path, 2048)
	if err != nil {
		return false
	}

	// Require at least 60% of signatures to match (reduces false positives)
	requiredMatches := (len(signatures) + 1) / 2 // Ceiling of 50%
	matchCount := 0

	for _, sig := range signatures {
		if strings.Contains(content, sig) {
			matchCount++
			if matchCount >= requiredMatches {
				return true
			}
		}
	}

	return false
}

func looksLikeLockFile(path string) bool {
	// Read larger sample for heuristic analysis
	content, err := readFileHeader(path, 4096)
	if err != nil {
		return false
	}

	// Check for common lock file characteristics:
	// 1. "lockfile", "lock-version", or "@generated" in header
	// 2. High density of version strings (x.y.z)
	// 3. High density of hash strings

	contentLower := strings.ToLower(content[:min(512, len(content))])

	// Check header markers
	lockMarkers := []string{
		"lockfile", "lock version", "lock-version",
		"autogenerated", "auto-generated", "@generated",
		"do not edit", "do not modify",
	}
	for _, marker := range lockMarkers {
		if strings.Contains(contentLower, marker) {
			return true
		}
	}

	// Check version density (count x.y.z patterns)
	versionCount := strings.Count(content, ".")
	if versionCount > 50 { // Arbitrary but reasonable threshold
		return true
	}

	return false
}

func readFileHeader(path string, bytes int) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()

	buf := make([]byte, bytes)
	n, _ := file.Read(buf)
	return string(buf[:n]), nil
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
